<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>selected_card = 0;  // What card is the AI thinking about?
move_interval = 5;  // Higher is slower
if (instance_exists(obj_network))
    move_interval = 1;

think_interval = 2; // Higher is slower

think_moves_culled = false; // Have we culled worthless moves yet?

// How many times will the AI "think" before making a move?
think_iterations = 0;
think_iteration_max = 20;

// How good must a move be before the AI picks it immediately?
think_best_move = 0;
think_move_score = 0;
think_score_threshold = 70;

// Create movelists.
think_possible_moves = ds_list_create();
think_unanalyzed_moves = ds_list_create();
for (var i = 0; i &lt; 5; i++) {
    for (var j = 0; j &lt; 16; j++) {
        ds_list_add(think_possible_moves, (i * 100) + j);
        ds_list_add(think_unanalyzed_moves, (i * 100) + j);
    }
}

think_first_move = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Free memory of movelists.
ds_list_destroy(think_possible_moves);
ds_list_destroy(think_unanalyzed_moves);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!GAME_STARTED) exit;
if (!TURN_IS_RED) exit;

var supposed_card = floor(think_best_move / 100);
var move_x = floor((think_best_move % 100) % 4);
var move_y = floor((think_best_move % 100) / 4)

if (selected_card &lt; supposed_card) {
    selected_card++;
    while (obj_game.red_hand[selected_card, 6]) {
        selected_card++;
    }
    play_sfx(snd_choose_card);
    alarm[1] = move_interval;
    
} else if (selected_card &gt; supposed_card) {
    selected_card--;
    while (obj_game.red_hand[selected_card, 6]) {
        selected_card--;
    }
    play_sfx(snd_choose_card);
    alarm[1] = move_interval;
    
} else if ( !instance_exists(obj_network) &amp;&amp;
            ((think_iterations == think_iteration_max) || 
            (think_move_score &gt;= think_score_threshold) ||
             ds_list_empty(think_unanalyzed_moves)) ) {
             
    place_card(move_x, move_y, selected_card + 5, true);
    with (obj_enemy_card) {
        if (supposed_card + 5 == hand_number) {
            instance_destroy();
        }
    }
    play_sfx(snd_choose_card);
    
    think_moves_culled = false;
    think_iterations = 0;
    think_best_move = 0;
    think_move_score = 0;
    selected_card = 0;
    think_iteration_max = 15 + irandom(10);
    
    end_turn(move_x, move_y);

} else {
    alarm[1] = move_interval;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!GAME_STARTED) exit;
if (!TURN_IS_RED) exit;

if (think_iterations &gt;= think_iteration_max) {
    if (alarm[1] == -1)
        alarm[1] = move_interval;
    exit;
}

if (!think_moves_culled) {
    think_possible_moves = cull_moves(think_possible_moves);
    ds_list_copy(think_unanalyzed_moves, think_possible_moves);
    think_first_move = (CARDS_PLACED == 0);
    think_moves_culled = true;
    think_move_score = -100000; 
    think_best_move = 0;
}

// Waste time to make it look like the computer is thinking
if (ds_list_empty(think_unanalyzed_moves)) {
    think_iterations += 2;
    exit;
}

ds_list_shuffle(think_unanalyzed_moves);
var analyze_move = think_unanalyzed_moves[| 0];
ds_list_delete(think_unanalyzed_moves, 0);

var move_x = floor((analyze_move % 100) % 4);
var move_y = floor((analyze_move % 100) / 4)
var supposed_card = floor(analyze_move / 100);
var move_potential = 0;

if (think_first_move) {

    var card_arrows = obj_game.red_hand[supposed_card, 5];
    var think_space_arrows = 0;
    
    for (var i = -1; i &lt;= 1; i++) {
        for (var j = -1; j &lt;= 1; j++) {
            if (i != 0 || j != 0) {
                if (move_possible(move_x + i, move_y + j)) {
                    var grid_card = obj_game.game_grid[move_x + i, move_y + j];
                    if (grid_card == GRID_EMPTY) {
                        think_space_arrows = think_space_arrows | get_arrow(i, j);
                    }
                }
            }
        }
    }
    
    move_potential = 80 - (10 * hamming_distance(card_arrows, think_space_arrows));
    
} else {

    free_takes = 0;
    card_battles = 0;
    for (var i = -1; i &lt;= 1; i++) {
        for (var j = -1; j &lt;= 1; j++) {
            if (i != 0 || j != 0) {
                move_potential += think_analyze_square(move_x, move_y, i, j, supposed_card);
            }
        }
    }
    
    // These takes aren't free anymore if there is a card battle
    // But they should have some worth
    if (card_battles) {
        move_potential -= 25 * free_takes;
    }
    
    // Discourage multiple card battles
    if (card_battles &gt; 1) {
        move_potential /= card_battles;
    }

}

if (move_potential &gt;= think_move_score) {
    think_best_move = analyze_move;
    think_move_score = move_potential;
}

think_iterations++;
alarm[0] = think_interval;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!GAME_STARTED) exit;

if (!TURN_IS_RED) {
    alarm[0] = -1;
    alarm[1] = -1;
}

if (TURN_IS_RED) {
    if (!instance_exists(obj_network) &amp;&amp; alarm[0] == -1)
        alarm[0] = think_interval;
    else if (instance_exists(obj_network) &amp;&amp; alarm[1] == -1)
        alarm[1] = move_interval;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
